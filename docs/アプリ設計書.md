# Cyrillic IME アプリ設計書 (v1.0)

## 1\. 設計思想とアーキテクチャ

本アプリケーションの設計は、「パフォーマンス（REQ-NF-001）」と「保守性（REQ-NF-004）」という二律背反の要件を両立させることを至上命題とする。

### 1.1. 哲学: 「正規化マッピング」の採用

本アプリの変換ロジックは、`И` $\rightarrow$ `い`（直接マッピング）を採用しない。
`И` $\rightarrow$ **`"i"` (音韻キー)** $\rightarrow$ `い`（正規化マッピング）を採用する。

  * **理由**: パフォーマンス上のデメリット（ナノ秒単位のルックアップ1回追加）は、ユーザー体験において無視できる（`Negligible`）レベルである。
  * **メリット**: 将来、「ひらがな」を「カタカナ（`チ`）」や「ローマ字（`chi`）」に一括変更したい場合、修正箇所は `japaneseKanaEngine.json` の1ファイルのみで完了する。これは「関心の分離（SoC）」と「DRY原則」に基づき、保守性を劇的に高めるための意図的なエンジニアリング的判断である。

### 1.2. アーキテクチャ: 「ハイブリッド・ネイティブ（Rust Core + Native UI）」

REQ-NF-001（パフォーマンス）と REQ-NF-004（保守性）を両立するため、以下のアーキテクチャを採用する。

  * **UI層 (Shell)**: iOS (Swift) と Android (Kotlin) でそれぞれネイティブ実装する。OSとの密な連携と、キー描画の最高パフォーマンスを確保する。
  * **Core層 (Engine)**: **Rust** で `cyrillic_ime_core` ライブラリを開発する。JSONのパース、`HashMap`による辞書保持、入力バッファの状態機械（State Machine）管理という、最も複雑なロジックを単一のコードベースで管理する。
  * **連携**: UI層はFFI (iOS) / JNI (Android) 経由でRust Coreを呼び出す。

## 2\. コンポーネント設計

### 2.1. Rust Core (`cyrillic_ime_core`)

  * **責務**: 「状態」と「ロジック」の管理。
  * **起動時**: バンドルされた全JSON（`profiles.json`, `japaneseKanaEngine.json`, `schemas/*.json`）を読み込み、`GlobalSchemaCache`（メモリ上の`HashMap`）に展開する。
  * **実行時**: ネイティブ層からキータップ（例: `key: 'Я'`）と現在の状態（例: `buffer: "К"`, `profile: "rus_standard"`）を受け取る。
  * **状態機械**:
    1.  バッファを更新 (`"К"` $\rightarrow$ `"КЯ"`)。
    2.  `schema_rus_v1`（`HashMap`）をルックアップ。
    3.  `"КЯ"` がヒット。`kana_key: "kya"` を返す。
    4.  `japaneseKanaEngine` をルックアップ。
    5.  `"kya"` がヒット。最終結果 `"きゃ"` と、バッファをクリアする指示をネイティブ層に返す。

### 2.2. Native UI (Swift / Kotlin)

  * **責務**: 「UI描画」と「OS連携」。
  * **`ProfileManager`**: ユーザーが選択した `currentProfileId`（例: `srb_cyrillic`）を `UserDefaults` / `SharedPreferences` に永続化し、状態を管理する。
  * **`KeyboardViewController` / `InputMethodService`**:
    1.  起動時に `ProfileManager` から `currentProfileId` を取得。
    2.  `profile.keyboardLayout` に基づきキーUIを描画。
    3.  `profile.inputSchemaId` をRust Coreに通知（使用するスキーマを指示）。
    4.  キータップをRust Coreの `process_key` 関数に転送。
    5.  Rust Coreからの戻り値（例: `"きゃ"`）をOS（`UITextDocumentProxy` / `InputConnection`）に渡す。

## 3\. UI/UX設計（プロファイル切替）

  * **UI**: キーボードUI上部（またはスペースバー横）に、現在のプロファイルを示すインジケーター（例: `[РУС]`）を常時表示する。
  * **アクション**: ユーザーがインジケーターをタップすると、`profiles.json` の `name_ja` リスト（"ロシア語", "セルビア語" ...）がポップアップ表示される。
  * **実行**: ユーザーが「セルビア語」を選択すると、`ProfileManager` が `currentProfileId` を `srb_cyrillic` に更新し、`KeyboardViewController` に通知する。
  * **再描画**: `KeyboardViewController` は通知を受け取り、Rust Coreに使用スキーマの変更を指示すると同時に、UIをセルビア語レイアウト（`Њ`, `Ћ` キー表示）に非同期で再描画する。

## 4\. データ構造（JSON）の哲学

JSONスキーマの設計は、\*\*「多様性（Schema）」**と**「普遍性（Engine）」\*\*の分離である。

  * **`schemas/*.json` (多様性)**:
      * **責務**: 「どう入力するか（HOW）」を定義する。
      * **哲学**: このファイルは、各言語文化（ロシア語、セルビア語）のタイピング習慣を記述する「憲章」である。`КЯ` を `kya` と解釈するか、`КЈА` を `kya` と解釈するかは、このファイルだけが知っていればよい。
  * **`japaneseKanaEngine.json` (普遍性)**:
      * **責務**: 「何を意味するか（WHAT）」を定義する。
      * **哲学**: これは、日本語の音韻と文字の「ロゼッタストーン」である。`kya` という音韻キーが `きゃ` を意味するという事実は、入力方法（ロシア語式かセルビア語式か）によらず普遍である。

この分離により、我々は（例えば）「ブルガリア語プロファイル」を追加する際、`japaneseKanaEngine.json` を一切触る必要がなく、`schema_bul_v1.json` を定義する**だけ**で済む。これが本設計が提供する最大の価値（保守性・拡張性）である。
